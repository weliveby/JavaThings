URLClassLoader实际上是我们平时默认使用的AppClassLoader的父类.
所以，我们解释URLClassLoader的工作过程实际上就是在解释默认的Java类加载器的工作流程。

正常情况下，Java会根据配置项sun.boot.class.path和java.class.path中列举到的基础路径（这些路径是经过处理后的java.net.URL类）来寻找.class文
件来加载，而这个基础路径有分为三种情况：

--URL未以斜杠/结尾，则认为是一个JAR文件，使用JarLoader来寻找类，即为在Jar包中寻找.class文件
--URL以斜杠/结尾，且协议名是file，则使用FileLoader来寻找类，即为在本地文件系统中寻找.class文件
--URL以斜杠/结尾，且协议名不是file，则使用最基础的Loader来寻找类

我们正常开发的时候通常遇到的是前两者，那什么时候才会出现使用Loader寻找类的情况呢？当然是非file协议的情况下，最常见的就是http协议。

---------------------------------------------------------------------------------------------------------------------------------------------

其实，不管是加载远程class文件，还是本地的class或jar文件，Java都经历的是下面这三个方法调用：

--loadClass的作用是从已加载的类缓存、父加载器等位置寻找类（这里实际上是双亲委派机制），在前面没有找到的情况下，执行findClass
--findClass的作用是根据基础URL指定的方式来加载类的字节码，就像上一节中说到的，可能会在本地文件系统、jar包或远程http服务器上读取字节码，然后交给
defineClass
--defineClass的作用是处理前面传入的字节码，将其处理成真正的Java类

所以可见，真正核心的部分其实是defineClass，他决定了如何将一段字节流转变成一个Java类，Java默认的ClassLoader#defineClass是一个native方法，逻
辑在JVM的C语言代码中。

------------------------------------------------------------------------------------------------------------------------

虽然大部分上层开发者不会直接使用到defineClass方法，但是Java底层还是有一些类用到了它，这就是TemplatesImpl。
另外，值得注意的是，TemplatesImpl中对加载的字节码是有一定要求的:这个字节码对应的类必须是com.sun.org.apache.xalan.internal.xsltc.runtime
.AbstractTranslet的子类。


